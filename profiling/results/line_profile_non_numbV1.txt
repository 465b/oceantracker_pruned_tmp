--OceanTracker preliminary set up
M: --------------------------------------------------------------------------
M: Starting OceanTracker  Version 0.3.04.001 2023-03-02
M:   Python version: 3.10.9 | packaged by conda-forge | (main, Jan 11 2023, 15:15:40) [MSC v.1916 64 bit (AMD64)]
M: --------------------------------------------------------------------------
M: --------------------------------------------------------------------------
M:   - Running OceanTracker started 2023-03-27 12:05:43.185153
M:   - Starting: Sounds
M:   - Sorting hyrdo model files in time order
M:         - Finished sorting hyrdo model  files 
M:   - Input directory: G:\Hindcasts_large\MalbroughSounds_10year_benPhD\2008
M: --------------------------------------------------------------------------
P001: --------------------------------------------------------------------------
P001:   - Starting case number   1,  Sounds at 2023-03-27T12:05:56.248587
P001: --------------------------------------------------------------------------
P001: >>> Note: Running in debug mode
P001:   - built case instances
P001:   - set up particle_release_groups
P001:   - initialized all classes
P001: >>> Warning: When using a terminal velocity, ensure time step is small enough that vertical displacement is a small fraction of the water depth, ie vertical Courant number < 1
P001: >>> Note: When use aged binned particle stats, to get un biases stats., need to stop releasing particles "max_age_to_bin"  or max("user_age_bin_edges")  before end of run, by setting  particle param "release_duration"
P001: >>> Note: When use aged binned particle stats, to get un biases stats., need to stop releasing particles "max_age_to_bin"  or max("user_age_bin_edges")  before end of run, by setting  particle param "release_duration"
P001: >>> Note: No open boundaries requested, as run_params["open_boundary_type"] = 0
P001:     Hint: Requires list of open boundary nodes not in hydro model, eg for Schism this can be read from hgrid file to named in reader params and run_params["open_boundary_type"] = 1
P001:   - Starting Sounds,  duration: 0.08333333333333333
P001: --------------------------------------------------------------------------
P001:   - Starting Sounds,  duration:  0.1 days
P001:   - Reading-file-01 schism_marl20080101_00z_3D.nc0000:0003 Steps in file   48 nt available 000 :003, file offsets    0 :    3  nt required    0:   3, number required:    4
P001:   -     read file at time 2008-01-01 00:30:00 file offsets 0000:0003 buffer offsets 000:003 Read:   4  time: 3001 ms
P001:     - Total time to fill buffer   3.0 sec
P001: 00%:000000:h000000:s00:b000:Day +00 00:00 2008-01-01 00:30:00: Rel.:001400: Active:01400 M:01323 S:00000 B:00077 D:000 O:00 N:0 Buffer:1400-  0% Step-16950 ms
P001: 25%:000001:h000001:s00:b001:Day +00 00:30 2008-01-01 01:00:00: Rel.:001400: Active:01400 M:01266 S:00000 B:00134 D:000 O:00 N:0 Buffer:1400-  0% Step-1108 ms
P001: 50%:000002:h000002:s00:b002:Day +00 01:00 2008-01-01 01:30:00: Rel.:002800: Active:02800 M:02531 S:00000 B:00269 D:000 O:00 N:0 Buffer:2800-  0% Step-3118 ms
P001: >>> Note: Running in debug mode
P001: >>> Warning: When using a terminal velocity, ensure time step is small enough that vertical displacement is a small fraction of the water depth, ie vertical Courant number < 1
P001: >>> Note: When use aged binned particle stats, to get un biases stats., need to stop releasing particles "max_age_to_bin"  or max("user_age_bin_edges")  before end of run, by setting  particle param "release_duration"
P001: >>> Note: When use aged binned particle stats, to get un biases stats., need to stop releasing particles "max_age_to_bin"  or max("user_age_bin_edges")  before end of run, by setting  particle param "release_duration"
P001: >>> Note: No open boundaries requested, as run_params["open_boundary_type"] = 0
P001:     Hint: Requires list of open boundary nodes not in hydro model, eg for Schism this can be read from hgrid file to named in reader params and run_params["open_boundary_type"] = 1
P001: --------------------------------------------------------------------------
P001:   - Finished case number   1,  Sounds started: 2023-03-27 12:05:56.246587, ended: 2023-03-27 12:06:26.829453
P001:       Elapsed time =0:00:30.582866
P001: --------------------------------------------------------------------------
M: --------------------------------------------------------------------------
M:   - Finished ---  started: 12002.1220412---  ended: 2023-03-27 12:06:26.893479
M:       Elapsed time =0:00:30.648893
M:         Output in F:\OceanTrackerOuput\OceanTrackerProfiling\Sounds
M: --------------------------------------------------------------------------
Wrote profile results to profileOT.py.lprof
Timer unit: 1e-07 s

Total time: 1.67685 s
File: e:\onedrive - cawthron\h_local_drive\particletracking\oceantracker\oceantracker\interpolator\util\triangle_interpolator_util.py
Function: BCwalk_with_move_backs_numba2D at line 55

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    55                                           @profile
    56                                           def BCwalk_with_move_backs_numba2D(xq, x_old, status, BC, BCtransform, triNeighbours, current_dry_cell_index, block_dry_cells,
    57                                                                              tol, max_BC_walk_steps, has_open_boundary, active, walk_stats, n_cell):
    58                                               # Barycentric walk across triangles to find cells
    59                                           
    60        26       4468.0    171.8      0.0      bc = np.full((3,), 0.)
    61                                           
    62                                               # loop over active particles in place
    63     35955     296413.0      8.2      1.8      for n in active:
    64                                           
    65     35929     330801.0      9.2      2.0          n_tri = n_cell[n]  # starting triangle
    66                                                   # do BC walk
    67     35929     245604.0      6.8      1.5          n_steps = 0
    68     35929    4966228.0    138.2     29.6          if np.any(~np.isfinite(xq[n, :])):
    69                                                       if np.all(np.isfinite(x_old[n, :])):
    70                                                           for i in range(xq.shape[1]): xq[n, i] = x_old[n, i]
    71                                                       else:
    72                                                           status[n] = status_bad_cord
    73                                                           continue
    74                                           
    75     35929     284704.0      7.9      1.7          move_back = False
    76                                           
    77     40736     302163.0      7.4      1.8          while n_steps < max_BC_walk_steps:
    78                                                       # update barcentric cords of xq
    79     40736    2077584.0     51.0     12.4              n_min, n_max = _get_single_BC_cord_numba(xq[n, :2], BCtransform[n_tri, :, :], bc)
    80                                           
    81     40736     629387.0     15.5      3.8              if bc[n_max] < 1. + tol and tol and bc[n_min] > -tol:
    82                                                           # are now inside triangle, leave particle status as is
    83     35012     251299.0      7.2      1.5                  break
    84                                           
    85      5724      44939.0      7.9      0.3              n_steps += 1
    86                                                       # move to neighbour triangle at face with smallest bc then test bc cord again
    87      5724      55443.0      9.7      0.3              next_tri = triNeighbours[n_tri, n_min]  # n_min is the face num in  tri to move across
    88                                           
    89      5724      52280.0      9.1      0.3              if next_tri < 0:
    90                                                           # if no new adjacent triangle, then are trying to exit domain at a boundary triangle,
    91                                                           # keep n_cell, bc  unchanged
    92                                                           if has_open_boundary and next_tri == -2:  # outside domain
    93                                                               # leave x, bc, cell, location  unchanged as outside
    94                                                               status[n] = status_outside_open_boundary
    95                                                               break
    96                                                           else:  # n_tri == -1 outside domain and any future
    97                                                               # solid boundary, so just move back
    98                                                               move_back = True
    99                                                               break
   100                                           
   101                                                       # check for dry cell
   102      5724      39437.0      6.9      0.2              if block_dry_cells:  # is faster split into 2 ifs, not sure why
   103      5268     167076.0     31.7      1.0                  if current_dry_cell_index[next_tri] > 128:
   104                                                               # treats dry cell like a lateral boundary,  move back and keep triangle the same
   105       917       6704.0      7.3      0.0                      move_back = True
   106       917       6157.0      6.7      0.0                      break
   107                                           
   108      4807      35133.0      7.3      0.2              n_tri = next_tri
   109                                           
   110                                                   # not found in given number of search steps
   111     35929     268901.0      7.5      1.6          if n_steps >= max_BC_walk_steps:  # dont update cell
   112                                                       status[n] = status_cell_search_failed
   113                                                       walk_stats['failed_walks'] += 1
   114                                                       move_back = True
   115                                           
   116     35929     243423.0      6.8      1.5          if move_back:
   117                                                       # move back dont update
   118      3668      47318.0     12.9      0.3              for i in range(xq.shape[1]): xq[n, i] = x_old[n, i]
   119                                                   else:
   120                                                       # update cell anc BC for new triangle
   121     35012     314533.0      9.0      1.9              n_cell[n] = n_tri
   122    140048    1572217.0     11.2      9.4              for i in range(3): BC[n, i] = bc[i]
   123                                           
   124                                                   # step count stats
   125     35929     969231.0     27.0      5.8          walk_stats['particles_located'] += 1
   126     35929     819057.0     22.8      4.9          walk_stats['total_steps'] += n_steps
   127                                           
   128                                                   # record max number of steps
   129     35929     579132.0     16.1      3.5          if n_steps > walk_stats['longest_walk']:
   130         2         33.0     16.5      0.0              walk_stats['longest_walk'] = n_steps + 1
   131                                           
   132     35929    2158883.0     60.1     12.9          walk_stats['histogram'][min(n_steps, walk_stats['histogram'].shape[0] - 1)] += 1

Total time: 2.65675 s
File: e:\onedrive - cawthron\h_local_drive\particletracking\oceantracker\oceantracker\interpolator\util\triangle_interpolator_util.py
Function: get_depth_cell_time_varying_Slayer_or_LSCgrid at line 195

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   195                                           @profile
   196                                           def get_depth_cell_time_varying_Slayer_or_LSCgrid(zq, nb, step_dt_fraction, z_level_at_nodes, tri, n_cell,
   197                                                                                             nz_with_bottom, BCcord, status,
   198                                                                                             nz_cell, nz_nodes, z_fraction,
   199                                                                                             z_fraction_bottom_layer, is_in_bottom_layer,
   200                                                                                             z0, active, walk_stats):
   201                                               # find the zlayer for each node of cell containing each particl eand at two time slices of hindcast  between nz_bottom and number of z levels
   202                                               # LSC grid means must track vertical nodes for each particle
   203                                               # nz_with_bottom is lowest cell in grid, is 0 for slayer vertical grids, but may be > 0 for LSC grids
   204                                               # nz_with_bottom must be time independent
   205                                           
   206        20        304.0     15.2      0.0      tf2 = 1. - step_dt_fraction
   207                                           
   208        20        255.0     12.8      0.0      top_nz_cell = z_level_at_nodes.shape[2] - 2
   209        20       3078.0    153.9      0.0      top_zlevel3 = np.full((3,), top_nz_cell, dtype=np.int32)
   210                                           
   211     33060     289194.0      8.7      1.1      for n in active:  # loop over active particles
   212     33040     449233.0     13.6      1.7          nodes = tri[n_cell[n], :]  # nodes for the particle's cell
   213     33040     979441.0     29.6      3.7          bottom_nz_nodes = nz_with_bottom[nodes]
   214     33040     398628.0     12.1      1.5          nz_below = nz_nodes[n, 0, :]
   215     33040     357088.0     10.8      1.3          nz_above = nz_nodes[n, 1, :]
   216                                           
   217     33040     230634.0      7.0      0.9          n_vertical_steps = 0
   218                                           
   219                                                   # current cell number
   220     33040    4670251.0    141.4     17.6          bottom_nz_cell = np.min(bottom_nz_nodes)  # cell at bottom
   221                                           
   222                                                   # preserve status if stranded by tide
   223     33040    1158517.0     35.1      4.4          if status[n] == status_stranded_by_tide:
   224                                                       nz_cell[n] = bottom_nz_cell
   225                                                       # update nodes above and below
   226                                                       z_below = _eval_z_at_nz_cell(nb, bottom_nz_cell, z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_below)
   227                                                       z_above = _eval_z_at_nz_cell(nb, bottom_nz_cell + 1, z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_above)
   228                                                       zq[n] = z_below
   229                                                       z_fraction[n] = 0.0
   230                                                       continue
   231                                           
   232                                                   # make any already on bottom active, may be flagged on bottom if found on bottom, below
   233     33040     890211.0     26.9      3.4          if status[n] == status_on_bottom:   status[n] = status_moving
   234                                           
   235                                                   # find zlevel above and below  current vertical cell
   236     33040    2088973.0     63.2      7.9          z_below = _eval_z_at_nz_cell(nb, nz_cell[n], z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_below)
   237     33040    1561608.0     47.3      5.9          z_above = _eval_z_at_nz_cell(nb, nz_cell[n] + 1, z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_above)
   238                                           
   239     33040     383305.0     11.6      1.4          if zq[n] >= z_below:
   240                                                       # search upwards, do nothing if z_above > zq[n] > z_below, ie current nodes are correct
   241     26220     265407.0     10.1      1.0              if zq[n] > z_above:
   242     11392     122990.0     10.8      0.5                  while nz_cell[n] < top_nz_cell:
   243      7555      58363.0      7.7      0.2                      n_vertical_steps += 1
   244      7555      94641.0     12.5      0.4                      nz_cell[n] += 1
   245      7555      53211.0      7.0      0.2                      z_below = z_above
   246      7555     250590.0     33.2      0.9                      nz_below[:] = nz_above.copy()
   247      7555     324400.0     42.9      1.2                      z_above = _eval_z_at_nz_cell(nb, nz_cell[n], z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_above)
   248      7555      86181.0     11.4      0.3                      if zq[n] <= z_above: break
   249                                                   else:
   250                                                       # search downwards
   251     19271     190481.0      9.9      0.7              while nz_cell[n] > bottom_nz_cell:
   252     17673     136528.0      7.7      0.5                  n_vertical_steps += 1
   253     17673     229419.0     13.0      0.9                  nz_cell[n] -= 1
   254     17673     124779.0      7.1      0.5                  z_above = z_below
   255     17673     581016.0     32.9      2.2                  nz_above[:] = nz_below.copy()
   256     17673     768522.0     43.5      2.9                  z_below = _eval_z_at_nz_cell(nb, nz_cell[n], z_level_at_nodes, bottom_nz_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, nz_below)
   257     17673     205473.0     11.6      0.8                  if zq[n] >= z_below: break  # found cell
   258                                           
   259                                                   # clip zq to be in bounds before calc. z_fraction
   260     33040    1305316.0     39.5      4.9          z_bot = _eval_z_at_nz_nodes(nb, z_level_at_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, bottom_nz_nodes)
   261     33040     418507.0     12.7      1.6          if zq[n] < z_bot + z0:
   262      1614      17029.0     10.6      0.1              zq[n] = z_bot
   263      1614      16768.0     10.4      0.1              status[n] = status_on_bottom
   264                                                   else:
   265                                                       # clip to surface only if not below bottom
   266     31426    1292671.0     41.1      4.9              z_surf = _eval_z_at_nz_nodes(nb, z_level_at_nodes, BCcord[n, :], step_dt_fraction, tf2, nodes, top_zlevel3)
   267     31426     367130.0     11.7      1.4              if zq[n] >= z_surf:
   268     12738     133557.0     10.5      0.5                  zq[n] = z_surf
   269                                           
   270                                                   # get z fraction
   271     33040     265051.0      8.0      1.0          dz = z_above - z_below
   272     33040     253914.0      7.7      1.0          if dz < z0:
   273       471       4563.0      9.7      0.0              z_fraction[n] = 0.0
   274                                                   else:
   275     32569     542817.0     16.7      2.0              z_fraction[n] = (zq[n] - z_below) / dz
   276                                           
   277     33040     343760.0     10.4      1.3          if nz_cell[n] == bottom_nz_cell:
   278      2309      22262.0      9.6      0.1              is_in_bottom_layer[n] = 1
   279      2309      18459.0      8.0      0.1              if dz < z0:
   280                                                           z_fraction_bottom_layer[n] = 0.0
   281                                                       else:
   282                                                           # adjust z fraction so that linear interp acts like log layer
   283      2309      18538.0      8.0      0.1                  z0p = z0 / dz
   284      2309     233768.0    101.2      0.9                  z_fraction_bottom_layer[n] = (np.log(z_fraction[n] + z0p) - np.log(z0p)) / (np.log(1. + z0p) - np.log(z0p))
   285                                           
   286                                                   # record number of vertical search steps made for this particle
   287                                                   # step count stats, tidal stranded particles are not counted
   288     33040    1011033.0     30.6      3.8          walk_stats['particles_located'] += 1
   289     33040     771625.0     23.4      2.9          walk_stats['total_steps'] += n_vertical_steps
   290                                                   # record max number of steps
   291     33040     550494.0     16.7      2.1          if n_vertical_steps > walk_stats['longest_walk']:
   292         1         16.0     16.0      0.0              walk_stats['longest_walk'] = n_vertical_steps + 1
   293                                           
   294     33040    2027530.0     61.4      7.6          walk_stats['histogram'][min(n_vertical_steps, walk_stats['histogram'].shape[0] - 1)] += 1

